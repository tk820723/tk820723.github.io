{"meta":{"title":"苇白的混沌空间 | 致虚极 守静笃","subtitle":"致虚极 守静笃","description":null,"author":"苇白","url":"http://www.spacevoid.cn","root":"/"},"pages":[],"posts":[{"title":"Golang 学习笔记3 -- 函数","slug":"Golang 学习笔记3 -- 函数","date":"2019-04-23T08:30:00.000Z","updated":"2019-04-23T11:08:25.914Z","comments":true,"path":"2019/04/23/Golang 学习笔记3 -- 函数/","link":"","permalink":"http://www.spacevoid.cn/2019/04/23/Golang 学习笔记3 -- 函数/","excerpt":"","text":"函数 main函数是你的程序的入口 定义1234func greet(fname, lname string) (r int) &#123; //接收两个string的参数，返回一个int值 fmt.Println(fname, lname) return //这里直接返回r作为返回值&#125; 返回两个参数的函数123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; id, err := ReturnId() if err != nil &#123; fmt.Printf(&quot;ERROR: %s&quot;, err) return &#125; fmt.Printf(&quot;Id: %d\\n&quot;, id)&#125;func ReturnId() (int, error) &#123; id := 10 return id, nil&#125; 值得注意的 函数返回两个值是go语法中常用的做法，一般来说第一个值是想要的函数返回值，第二个返回值通常与错误处理相关 如果你不关心错误，你可以使用下划线来代替第二个参数：id, _ = ReturnFuc() 在函数中，如果你命名了返回值的变量，相当于构造了这个函数作用域中的变量，请小心作用域陷阱: https://www.goinggo.net/2013/10/functions-and-naked-returns-in-go.html 返回不定个参数的函数12345678910func add(a ...int) int &#123; // 传入的这个a的类型为切片，后面的笔记还会说到切片，这里仅作为了解即可 sum := 0 for _, i := range a &#123; sum += i &#125; return sum&#125;data := []int&#123;43, 56, 87, 12, 45, 57&#125; //创建一个切片n := add(data...) //将切片传入，不可传入数组 切片当参数的函数12345678910func add(a []int) int &#123; // 传入的这个a的类型为切片，后面的笔记还会说到切片，这里仅作为了解即可 sum := 0 for _, i := range a &#123; sum += i &#125; return sum&#125;data := []int&#123;43, 56, 87, 12, 45, 57&#125; //创建一个切片n := add(data...) //将切片传入，不可传入数组 函数指针123456789func main() &#123; //函数指针相当于代码块的概念，这个指针可以把一段代码块当成是参数来进行传递，常用于回调的传递 greeting := func() &#123; fmt.Println(&quot;Hello world!&quot;) &#125; greeting() fmt.Printf(&quot;%T\\n&quot;, greeting)&#125; 12345678910func makeGreeter() func() string &#123; return func() string &#123; return &quot;Hello world!&quot; &#125;&#125;func main() &#123; greet := makeGreeter() fmt.Println(greet())&#125; 匿名函数匿名函数是指没有定义名字符号的函数 直接调用 12345func main() &#123; func(s string) &#123; println(s) &#125;(&quot;hello,world!&quot;)&#125; 复值给变量 1234567func main() &#123; add:=func(x,y int)int&#123; return x+y &#125; println(add(1,2))&#125; 作为参数 123456789func test(f func()) &#123; f()&#125;func main() &#123; test(func() &#123; println(&quot;hello,world!&quot;) &#125;)&#125; 作为返回值 12345678910func test()func(int,int)int&#123; return func(x,y int)int&#123; return x+y &#125;&#125;func main() &#123; add:=test() println(add(1,2))&#125; 闭包: 闭包就是匿名函数，匿名函数可以引用外面的局部变量，当闭包没有执行完毕的时候，局部变量不会被释放，并且在闭包里面修改变量值会影响整个变量","categories":[{"name":"golang","slug":"golang","permalink":"http://www.spacevoid.cn/categories/golang/"}],"tags":[]},{"title":"Golang 学习笔记3 -- 函数","slug":"Golang 学习笔记4","date":"2019-04-23T08:30:00.000Z","updated":"2019-04-24T02:49:00.792Z","comments":true,"path":"2019/04/23/Golang 学习笔记4/","link":"","permalink":"http://www.spacevoid.cn/2019/04/23/Golang 学习笔记4/","excerpt":"","text":"函数 main函数是你的程序的入口 定义1234func greet(fname, lname string) (r int) &#123; //接收两个string的参数，返回一个int值 fmt.Println(fname, lname) return //这里直接返回r作为返回值&#125; 返回两个参数的函数123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; id, err := ReturnId() if err != nil &#123; fmt.Printf(&quot;ERROR: %s&quot;, err) return &#125; fmt.Printf(&quot;Id: %d\\n&quot;, id)&#125;func ReturnId() (int, error) &#123; id := 10 return id, nil&#125; 值得注意的 函数返回两个值是go语法中常用的做法，一般来说第一个值是想要的函数返回值，第二个返回值通常与错误处理相关 如果你不关心错误，你可以使用下划线来代替第二个参数：id, _ = ReturnFuc() 在函数中，如果你命名了返回值的变量，相当于构造了这个函数作用域中的变量，请小心作用域陷阱: https://www.goinggo.net/2013/10/functions-and-naked-returns-in-go.html 返回不定个参数的函数12345678910func add(a ...int) int &#123; // 传入的这个a的类型为切片，后面的笔记还会说到切片，这里仅作为了解即可 sum := 0 for _, i := range a &#123; sum += i &#125; return sum&#125;data := []int&#123;43, 56, 87, 12, 45, 57&#125; //创建一个切片n := add(data...) //将切片传入，不可传入数组 切片当参数的函数12345678910func add(a []int) int &#123; // 传入的这个a的类型为切片，后面的笔记还会说到切片，这里仅作为了解即可 sum := 0 for _, i := range a &#123; sum += i &#125; return sum&#125;data := []int&#123;43, 56, 87, 12, 45, 57&#125; //创建一个切片n := add(data...) //将切片传入，不可传入数组 函数指针123456789func main() &#123; //函数指针相当于代码块的概念，这个指针可以把一段代码块当成是参数来进行传递，常用于回调的传递 greeting := func() &#123; fmt.Println(&quot;Hello world!&quot;) &#125; greeting() fmt.Printf(&quot;%T\\n&quot;, greeting)&#125; 12345678910func makeGreeter() func() string &#123; return func() string &#123; return &quot;Hello world!&quot; &#125;&#125;func main() &#123; greet := makeGreeter() fmt.Println(greet())&#125; 匿名函数匿名函数是指没有定义名字符号的函数 直接调用 12345func main() &#123; func(s string) &#123; println(s) &#125;(&quot;hello,world!&quot;)&#125; 复值给变量 1234567func main() &#123; add:=func(x,y int)int&#123; return x+y &#125; println(add(1,2))&#125; 作为参数 123456789func test(f func()) &#123; f()&#125;func main() &#123; test(func() &#123; println(&quot;hello,world!&quot;) &#125;)&#125; 作为返回值 12345678910func test()func(int,int)int&#123; return func(x,y int)int&#123; return x+y &#125;&#125;func main() &#123; add:=test() println(add(1,2))&#125; 闭包: 闭包就是匿名函数，匿名函数可以引用外面的局部变量，当闭包没有执行完毕的时候，局部变量不会被释放，并且在闭包里面修改变量值会影响整个变量","categories":[{"name":"golang","slug":"golang","permalink":"http://www.spacevoid.cn/categories/golang/"}],"tags":[]},{"title":"Golang 学习笔记2 -- for、switch、if-else","slug":"Golang 学习笔记2 -- for、switch、if-else","date":"2019-04-23T07:23:31.000Z","updated":"2019-04-23T11:09:38.085Z","comments":true,"path":"2019/04/23/Golang 学习笔记2 -- for、switch、if-else/","link":"","permalink":"http://www.spacevoid.cn/2019/04/23/Golang 学习笔记2 -- for、switch、if-else/","excerpt":"","text":"For循环基础init12345for i := 0; i &lt; 5; i++ &#123; for j := 0; j &lt; 5; j++ &#123; fmt.Println(i, &quot; - &quot;, j) &#125;&#125; 替代While循环12345i := 0for i &lt; 10 &#123; // 可以看成是 while(i&lt;10)&#123;...&#125; fmt.Println(i) i++&#125; Switch有表达式的123456789var i = 1switch i &#123;case 0: fmt.Println(&quot;0&quot;)case 1: fmt.Println(&quot;1&quot;) //最后打印1default: fmt.Println(&quot;default&quot;)&#125; 没有表达式的123456789var i = 1switch &#123;case i == 0: fmt.Println(&quot;0&quot;)case i == 1: fmt.Println(&quot;1&quot;) //最后打印1default: fmt.Println(&quot;default&quot;)&#125; If-else if后面可以插入一个初始化表达式，然后用分号隔开判断条件 1234567891011b := truec := falseif food := &quot;Chocolate&quot;; b &#123; //这句话里面的food先被初始化为Chocolate，然后再判断b的bool值 fmt.Println(food) &#125;else if c&#123; //dosomething&#125;else&#123; //dosomething&#125;// fmt.Println(food) //被初始化的food只在if区域内生效，这句话food没有初始化","categories":[{"name":"golang","slug":"golang","permalink":"http://www.spacevoid.cn/categories/golang/"}],"tags":[]},{"title":"Golang 学习笔记1 -- 基础类型、fmt、工作空间、指针","slug":"Golang 学习笔记1 -- 基础类型、fmt、工作空间、指针","date":"2019-04-23T06:44:54.000Z","updated":"2019-04-23T11:08:49.160Z","comments":true,"path":"2019/04/23/Golang 学习笔记1 -- 基础类型、fmt、工作空间、指针/","link":"","permalink":"http://www.spacevoid.cn/2019/04/23/Golang 学习笔记1 -- 基础类型、fmt、工作空间、指针/","excerpt":"","text":"基础类型12345678910111213a := 10 //int 默认值:0b := &quot;golang&quot; //string 默认值:（空）c := 4.17 //float64 默认值:0d := true //bool 默认值:falsee := &quot;Hello&quot; //stringf := `Do you like my hat?` //stringg := &apos;M&apos; //int32 == c语言的char go语言没有charconst ( // iota属于枚举类型 a = iota // 0 b // 1 c // 2) 类型的初始化123var myVariable = 123 //可变类型const myVariable = 123 //不可变myVariable := 123 //自动推断 fmtPrintf占位符1234567常用占位符占位符 说明 举例 输出%v 相应值的默认格式。 Printf(&quot;%v&quot;, people) &#123;zhangsan&#125;，%+v 打印结构体时，会添加字段名 Printf(&quot;%+v&quot;, people) &#123;Name:zhangsan&#125;%#v 相应值的Go语法表示 Printf(&quot;#v&quot;, people) main.Human&#123;Name:&quot;zhangsan&quot;&#125;%T 相应值的类型的Go语法表示 Printf(&quot;%T&quot;, people) main.Human%% 字面上的百分号，并非值的占位符 Printf(&quot;%%&quot;) % Scanfmt.Scan(&amp;variable) //读取用户输入的并且存入varible 工作空间（Workspace） 工作空间由src、bin、pkg三个目录组成 src - 保存所有源代码的目录 bin和pkg主要影响go install/get命令 通常需要将空间路径添加到GOPATH环境变量才可以 package由同一个目录下的文件组成，可以看成是namespace，不一定要和目录名字重合 指针基本使用123456a := 43var b = &amp;afmt.Println(b) //a的地址fmt.Println(&amp;b) //b的地址fmt.Println(*b) //a的值 值传递与地址传递 函数中参数如果是基础类型为值传递 123456789func zero(z int) &#123; z = 0&#125;func main() &#123; x := 5 zero(x) fmt.Println(x) // x仍然是5&#125; 如果想要在函数中的更改外头也生效，需要传递指针 123456789func zero(z *int) &#123; *z = 0&#125;func main() &#123; x := 5 zero(&amp;x) fmt.Println(x) // x is 0&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://www.spacevoid.cn/categories/golang/"}],"tags":[]},{"title":"更好的NSLog","slug":"更好的NSLog","date":"2019-04-18T08:08:18.000Z","updated":"2019-04-23T10:53:05.139Z","comments":true,"path":"2019/04/18/更好的NSLog/","link":"","permalink":"http://www.spacevoid.cn/2019/04/18/更好的NSLog/","excerpt":"","text":"更好的NSLog自从Xcode9之后，系统的消息里头加入了很多的其实并不需要的log，再加上各种第三方的log，整个log console看的非常的杂乱，想要看见自己的log很困难。 第一步，让我们来一一解决掉系统的log系统的log有两种类型，一个是UI新出的main tread checker的log，以及系统输出的NSLog 干掉main tread checker只需要在scheme编辑中选择Diagnostics tag，然后将main tread checker的勾选消除掉，就可以屏蔽掉此类log。 系统输出NSLog这个比较复杂，因为没有入口可以将它关闭，只能通过关闭NSLog输出来间接关闭系统的输出。有些童鞋会问，那NSLog被关闭自己想要输出怎么办，没关系，这个后面会说，这里先说下如何关闭NSLog的输出。想要关闭NSLog，也是在scheme编辑中，在Arguments tag下，增加”OS_ACTIVITY_DT_MODE”的key，然后设置value为NO，就可以关闭所有的NSLog的输出（包括第三方和自己的） 第二步，让我们来解决掉一些第三方的log其实在第一步的时候我们已经干掉了大部分第三方的log（通过干掉NSLog），我这边观察，还剩下GoogleFireBase的各种log还在输出，这个就需要进入到相对应的第三方的文档去查看如何关闭。以GoogleFireBase的输出为例，想要关闭GoogleFirebase的输出，只需要在初始化App的时候，将firebase的loggerLevel设置为min即可：1[[FIRConfiguration sharedInstance] setLoggerLevel:FIRLoggerLevelMin]; 第三步，使用我们更加好用的log来进行输出。现在大部分iOS程序员都知道通过使用另外一个Log来输出进行Debug和Release的区分（Release不需要输出log），这里直接上代码：123456//DLog 打印，debug下打印 非debug不打印#ifdef DEBUG#define DLog(FORMAT, ...) fprintf(stderr,&quot;%s\\n&quot;, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);#else#define DLog(...)#endif 使用DLog来代替原来的NSLog，中间的参数可以自己选择调整，我这里把基本上用不上的时间输出给去掉了，只留下比较基础的东西，需要其他的可以自己修改，然后将DLog放入全局的引用中就可以愉快的使用log去Debug了","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://www.spacevoid.cn/categories/iOS开发/"}],"tags":[]},{"title":"关于如何编写Hexo博客总结（二）","slug":"关于如何编写Hexo博客总结（二）","date":"2016-06-17T06:56:50.000Z","updated":"2019-04-23T10:53:02.103Z","comments":true,"path":"2016/06/17/关于如何编写Hexo博客总结（二）/","link":"","permalink":"http://www.spacevoid.cn/2016/06/17/关于如何编写Hexo博客总结（二）/","excerpt":"","text":"Markdown编辑器上一片讲了一些hexo用的markdown语法，这一片主要介绍一下在mac上编写markdown的时候使用的一些工具。 Ulysses 根据实际体验，与其说 Ulysses 是个富有创造性功能的应用，倒不如称它为融合了各类 Markdown 编辑器特点的集合体。 Ulysses算是名气最响的markdown编辑器了，功能上比较强大，除了实时编写实时查看效果以外，还自带功能强大的文档文件管理器，UI非常像邮件APP，也符合了markdown的宗旨。基本可以直接导入你的md文件夹进行编辑，无需每次编辑的时候再去导入，省去了不少麻烦。不过功能强大也带来了一些麻烦，Ulysses会自动对你编辑的东西进行一个自动格式调整，比如会自动把你本地图片换成标识符放在文章最底部，对于一些Hexo本身的插件会有冲突，所以我没有用这个，如果对于格式不用插件的同学，强烈推荐这个软件，使用起来真的很简单。 Mou Mou 的最大優點是針對中文有比較多的優化，比如對中文輸入時發生行高「漂移」這一 Mac 文本編輯軟件普遍存在的問題做了處理；標點自動配對也有相應完善；還有一個很甜的功能 —— 直行書寫。另外預覽模式也比較靈活。我認為目前唯一缺憾就是所謂的「打字機模式」了，也就是把編輯點固定在文檔窗口的中心點。 Mou算是名气仅次于Ulysses的编辑器，功能与Ulysses差别不大，但是比Ulysses干净。Mou支持直接打开并且保存md文件，在控制台直接hexo new一个文件之后，就可以用mou来直接编辑了，非常方便。 TyporaTypora和前两款编辑器最大的不同，在于他查看效果的方式并不是分屏查看，而是编辑一行之后，立刻应用效果。 markdown的编辑器一搜有很多，这里就不一一介绍了，读者可以挑选一款适合自己编写习惯的来使用。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.spacevoid.cn/categories/Hexo/"}],"tags":[]},{"title":"关于如何编写hexo博客总结（一）","slug":"关于如何编写hexo博客总结（一）","date":"2016-06-16T07:40:33.000Z","updated":"2019-04-23T10:52:48.606Z","comments":true,"path":"2016/06/16/关于如何编写hexo博客总结（一）/","link":"","permalink":"http://www.spacevoid.cn/2016/06/16/关于如何编写hexo博客总结（一）/","excerpt":"","text":"Hexo博客也建起来一阵子了，一直没有更新过，现在回来想写点东西，突然发现已经不太记得怎么编写了，所以现在边学习边把编写博客的记录下来。 Hexo用的是markdown语法，我就先从markdown讲起，关于markdown，已经有很不错的教程，所以这里参考转载了简述上Te_Lee的一篇简书 Markdown语法 Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown 语法的简要规则标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可 这里是引用 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 图片为：![](){ImgCap}{/ImgCap} 链接为：[]() 这两种方法都需要图片云服务的支持，你可以使用七牛或者原博主推荐的围脖图床修复计划 与 CloudApp 的服务，生成URL地址。小编找了很久，终于找到如何在Hexo里头使用本地图片的方法，参考下面这篇博客：在hexo 中无痛使用本地图片 作者： M-x codefalling，使用：![imageName](postname/image.jpg)方法 推酷地址：http://www.tuicool.com/articles/umEBVfI 补充：使用了两种发式之后，我发现虽然使用本地图片没有上传图片的痛苦了，但是相对传输速度要比专门的图床慢很多，如果不是懒人的话，还是建议使用图床外链url的形式。 表格例子如下：| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： 分割线分割线的语法只需要三个 ｀*｀ 号，例如： ***","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.spacevoid.cn/categories/Hexo/"}],"tags":[]},{"title":"Hexo插入音乐播放器","slug":"音乐播放器","date":"2016-04-29T02:17:19.000Z","updated":"2019-04-23T10:53:12.554Z","comments":true,"path":"2016/04/29/音乐播放器/","link":"","permalink":"http://www.spacevoid.cn/2016/04/29/音乐播放器/","excerpt":"","text":"这个网站也弄了一阵子，感觉图片什么都可以顺利加载了，顺便研究了一下如何插入网易音乐的模块。如果想像小编一样在侧边栏加入音乐播放器，可以在hexo themes/你的主体/layout/widget目录下创建music.ejs文件，插入以下代码： &lt;% if (site.tags.length) { %&gt; 音乐播放器 &lt;% } %&gt;并且修改在主体目录下的_config.yml文件，在widgets栏下面添加-music进行加载即可，详细外链播放器代码参数在下面有说明。下面转载一个iframe版本的外链播放器代码参数：width height 为显示的宽高链接中的id为歌单id，可以上网页版网易音乐云获取。auto参数为1则自动播放，0默认不自动播放下面是示例：","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.spacevoid.cn/categories/Hexo/"}],"tags":[]},{"title":"个人写的一个弹窗控件","slug":"个人写的一个弹窗控件","date":"2016-04-27T03:09:06.000Z","updated":"2019-04-23T10:52:31.464Z","comments":true,"path":"2016/04/27/个人写的一个弹窗控件/","link":"","permalink":"http://www.spacevoid.cn/2016/04/27/个人写的一个弹窗控件/","excerpt":"","text":"最近公司工作需要做一个从下往上的弹窗，但是我发现原生Actionsheet不是很好用，所以就自己写了一个弹窗控件。 github地址：https://github.com/tk820723/WBCustomActionSheet 使用起来非常简单。类方法传入弹框标题文字，然后使用类似tableview的datasource使用方法，每一个按钮样式都可以传进去，可以不为每个按钮绑定方法，使用delegate的didSelectIndex来判断也可以。显示出来调用showAnimated即可。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://www.spacevoid.cn/categories/iOS开发/"}],"tags":[]},{"title":"mac下还原pvr与plist为多个png","slug":"mac下还原pvr与plist为多个png","date":"2016-04-20T09:06:34.000Z","updated":"2019-04-23T10:52:28.368Z","comments":true,"path":"2016/04/20/mac下还原pvr与plist为多个png/","link":"","permalink":"http://www.spacevoid.cn/2016/04/20/mac下还原pvr与plist为多个png/","excerpt":"","text":"在网上找了很久，如何把很多网上下载的ipa包中扣出的图片资源（通常为pvr与plist结合格式）还原为png，只找到了一些python写的代码，但是mac下跑不起来，一直没有找到很好的自动化方法，就自己写了一个mac软件，帮助处理自动化切图。需要自己传入相应的png大图路径，plist文件路径，以及输出目录路径 控制器代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@interface ViewController ()@property (weak) IBOutlet NSTextField *pngPathField;@property (weak) IBOutlet NSTextField *plistPathField;@property (weak) IBOutlet NSTextField *targetPathField;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];&#125;- (IBAction)BtnClicked:(NSButton *)sender &#123;if (_pngPathField.stringValue.length == 0 || _plistPathField.stringValue.length == 0 || _targetPathField.stringValue.length == 0) &#123;NSLog(@\"输入路径不能为空\");return;&#125;//读取所有的文件，转换为数据数组NSString *pngPath = _pngPathField.stringValue;NSString *plistPath = _plistPathField.stringValue;NSString *targetPath = _targetPathField.stringValue;NSDictionary *plistDic = [NSDictionary dictionaryWithContentsOfFile:plistPath];NSDictionary *framesDic = [plistDic valueForKey:@\"frames\"];NSArray *framesArray = framesDic.allValues;NSArray *namesArray = framesDic.allKeys;if (framesArray.count==0||namesArray.count==0) &#123;NSLog(@\"字典文件没有对象\");return;&#125;//遍历数组转换plist数据for (int i = 0; i&lt; namesArray.count; i++) &#123;NSString *picName = namesArray[i];NSDictionary *singleImageFrameDic = framesArray[i];BOOL rotated = [[singleImageFrameDic objectForKey:@\"rotated\"] boolValue];NSRect frame = NSRectFromString([singleImageFrameDic valueForKey:@\"frame\"]);if (rotated) &#123;frame = NSMakeRect(frame.origin.x, frame.origin.y, frame.size.height, frame.size.width);&#125;else&#123;frame = NSMakeRect(frame.origin.x, frame.origin.y, frame.size.width, frame.size.height);&#125;NSImage *image = [[NSImage alloc] initWithContentsOfFile:pngPath];CGImageRef cutImageRef = [self cutImage:image frame:frame];[self WriteImageRefToFile:cutImageRef path:targetPath withImageName:picName];&#125;NSLog(@\"输入图片成功\");&#125;//根据数据切割图片，返回切割完的图片ref- (CGImageRef)cutImage: (NSImage *)image frame: (NSRect)frame&#123;CGImageSourceRef source = CGImageSourceCreateWithData((CFDataRef)[image TIFFRepresentation], NULL);CGImageRef maskRef = CGImageSourceCreateImageAtIndex(source, 0, NULL);CGImageRef finalImgRef = CGImageCreateWithImageInRect(maskRef, frame);return finalImgRef;&#125;//把图片输出到选择的目录- (void)WriteImageRefToFile: (CGImageRef) image path: (NSString *)path withImageName: (NSString *)imageName&#123;NSString *desPath = [NSString stringWithFormat:@\"%@/%@\",path,imageName];CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:desPath];CGImageDestinationRef destination = CGImageDestinationCreateWithURL(url, kUTTypePNG, 1, NULL);CGImageDestinationAddImage(destination, image, nil);if (!CGImageDestinationFinalize(destination)) &#123;NSLog(@\"Failed to write image to %@\", path);&#125;CFRelease(destination);&#125;- (void)setRepresentedObject:(id)representedObject &#123;[super setRepresentedObject:representedObject];// Update the view, if already loaded.&#125;@end","categories":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"http://www.spacevoid.cn/categories/cocos2dx/"}],"tags":[]},{"title":"hexo deploy 部署github缓慢解决方法","slug":"hexo-deploy-缓慢解决方法","date":"2016-04-20T08:46:16.000Z","updated":"2019-04-23T10:52:16.651Z","comments":true,"path":"2016/04/20/hexo-deploy-缓慢解决方法/","link":"","permalink":"http://www.spacevoid.cn/2016/04/20/hexo-deploy-缓慢解决方法/","excerpt":"","text":"不知道出于什么原因，使用hexo deploy部署到github会非常缓慢，有时候一个小时都没反应。查询了一大堆资源都没有找到解决方法，后来结合github部署个人网站原理，其实更改的最主要就是index.html这个静态网页。所以尝试手动push到github，这样部署过程就快很多了。步骤如下：＊ 新建一个文件夹，cd到这个目录，使用git init初始化git然后git remote add origin https://github.com/你的用户名/你的用户名.github.io 给这个目录连接到你的网页＊ git pull origin master 拉下当前目录＊ 然后把hexo在你本地网页目录下生成的public所有东西替换进新建的这个文件夹＊ 然后push一下这个文件夹，整个部署就完成了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.spacevoid.cn/categories/Hexo/"}],"tags":[{"name":"Hexo deploy","slug":"Hexo-deploy","permalink":"http://www.spacevoid.cn/tags/Hexo-deploy/"}]},{"title":"这是第一篇主页文章，我决定把他拿来测试","slug":"终于把Hexo服务器弄好了","date":"2016-04-20T05:30:49.000Z","updated":"2016-04-20T07:00:01.000Z","comments":true,"path":"2016/04/20/终于把Hexo服务器弄好了/","link":"","permalink":"http://www.spacevoid.cn/2016/04/20/终于把Hexo服务器弄好了/","excerpt":"","text":"折腾半天终于把Hexo服务器弄好了，主要是各种装了一半失败，然后查阅资料，原来是翻墙的原因。翻了墙之后又遇到国内hexo2.0和3.0教程不兼容问题，公司网络连接github也是时好时坏，磕磕碰碰终于搞好了一个网站。可以用来装逼了哈哈。下面👇全是学习hexo的测试。 这是一段blockquote Weibai LuQueteMe.com Code Block1NSLog(@\"Hello codeblock!\");","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.spacevoid.cn/categories/Hexo/"}],"tags":[]}]}