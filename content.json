{"meta":{"title":"一半游云 一半凌霄","subtitle":null,"description":null,"author":"Weibai Lu","url":"http://tk820723.github.io"},"pages":[],"posts":[{"title":"mac下还原pvr与plist为多个png","slug":"mac下还原pvr与plist为多个png","date":"2016-04-20T09:06:34.000Z","updated":"2016-04-20T09:25:05.000Z","comments":true,"path":"2016/04/20/mac下还原pvr与plist为多个png/","link":"","permalink":"http://tk820723.github.io/2016/04/20/mac下还原pvr与plist为多个png/","excerpt":"","keywords":null,"text":"在网上找了很久，如何把很多网上下载的ipa包中扣出的图片资源（通常为pvr与plist结合格式）还原为png，只找到了一些python写的代码，但是mac下跑不起来，一直没有找到很好的自动化方法，就自己写了一个mac软件，帮助处理自动化切图。需要自己传入相应的png大图路径，plist文件路径，以及输出目录路径 Code Block1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (IBAction)BtnClicked:(NSButton *)sender &#123; if (_pngPathField.stringValue.length == 0 || _plistPathField.stringValue.length == 0 || _targetPathField.stringValue.length == 0) &#123; NSLog(@\"输入路径不能为空\"); return; &#125; //读取所有的文件，转换为数据数组 NSString *pngPath = _pngPathField.stringValue; NSString *plistPath = _plistPathField.stringValue; NSString *targetPath = _targetPathField.stringValue; NSDictionary *plistDic = [NSDictionary dictionaryWithContentsOfFile:plistPath]; NSDictionary *framesDic = [plistDic valueForKey:@\"frames\"]; NSArray *framesArray = framesDic.allValues; NSArray *namesArray = framesDic.allKeys; if (framesArray.count==0||namesArray.count==0) &#123; NSLog(@\"字典文件没有对象\"); return; &#125; //遍历数组转换plist数据 for (int i = 0; i&lt; namesArray.count; i++) &#123; NSString *picName = namesArray[i]; NSDictionary *singleImageFrameDic = framesArray[i]; NSString *frameValueString = [singleImageFrameDic valueForKey:@\"frame\"]; NSString *sizeStringTemp =[[frameValueString componentsSeparatedByString:@\"&#125;,&#123;\"] lastObject]; NSString *sizeString = [sizeStringTemp substringToIndex:sizeStringTemp.length-2]; CGSize size = CGSizeMake([[[sizeString componentsSeparatedByString:@\",\"] firstObject] floatValue], [[[sizeString componentsSeparatedByString:@\",\"] lastObject] floatValue]); NSString *originString = [[[frameValueString componentsSeparatedByString:@\"&#125;,&#123;\"] firstObject] substringFromIndex:2]; CGPoint origin = CGPointMake([[[originString componentsSeparatedByString:@\",\"] firstObject] floatValue], [[[originString componentsSeparatedByString:@\",\"] lastObject] floatValue]); NSImage *image = [[NSImage alloc] initWithContentsOfFile:pngPath]; CGImageRef cutImageRef = [self cutImage:image size:size origin:origin]; [self WriteImageRefToFile:cutImageRef path:targetPath withImageName:picName]; &#125; NSLog(@\"输入图片成功\");&#125;//根据数据切割图片，返回切割完的图片ref- (CGImageRef)cutImage: (NSImage *)image size: (CGSize)size origin: (CGPoint)origin&#123; CGImageSourceRef source = CGImageSourceCreateWithData((CFDataRef)[image TIFFRepresentation], NULL); CGImageRef maskRef = CGImageSourceCreateImageAtIndex(source, 0, NULL); CGImageRef finalImgRef = CGImageCreateWithImageInRect(maskRef, CGRectMake(origin.x, origin.y, size.width, size.height)); return finalImgRef;&#125;//把图片输出到选择的目录- (void)WriteImageRefToFile: (CGImageRef) image path: (NSString *)path withImageName: (NSString *)imageName&#123; NSString *desPath = [NSString stringWithFormat:@\"%@/%@\",path,imageName]; CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:desPath]; CGImageDestinationRef destination = CGImageDestinationCreateWithURL(url, kUTTypePNG, 1, NULL); CGImageDestinationAddImage(destination, image, nil); if (!CGImageDestinationFinalize(destination)) &#123; NSLog(@\"Failed to write image to %@\", path); &#125; CFRelease(destination);&#125;","raw":null,"content":null,"categories":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"http://tk820723.github.io/categories/cocos2dx/"}],"tags":[]},{"title":"hexo deploy 部署github缓慢解决方法","slug":"hexo-deploy-缓慢解决方法","date":"2016-04-20T08:46:16.000Z","updated":"2016-04-20T09:04:07.000Z","comments":true,"path":"2016/04/20/hexo-deploy-缓慢解决方法/","link":"","permalink":"http://tk820723.github.io/2016/04/20/hexo-deploy-缓慢解决方法/","excerpt":"","keywords":null,"text":"不知道出于什么原因，使用hexo deploy部署到github会非常缓慢，有时候一个小时都没反应。查询了一大堆资源都没有找到解决方法，后来结合github部署个人网站原理，其实更改的最主要就是index.html这个静态网页。所以尝试手动push到github，这样部署过程就快很多了。步骤如下： ＊ 新建一个文件夹，cd到这个目录，使用git init初始化git然后git remote add origin https://github.com/你的用户名/你的用户名.github.io 给这个目录连接到你的网页 ＊ git pull origin master 拉下当前目录 ＊ 然后把hexo在你本地网页目录下生成的public所有东西替换进新建的这个文件夹 ＊ 然后push一下这个文件夹，整个部署就完成了","raw":null,"content":null,"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://tk820723.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo deploy","slug":"Hexo-deploy","permalink":"http://tk820723.github.io/tags/Hexo-deploy/"}]},{"title":"这是第一篇主页文章，我决定把他拿来测试","slug":"终于把Hexo服务器弄好了","date":"2016-04-20T05:30:49.000Z","updated":"2016-04-20T07:00:01.000Z","comments":true,"path":"2016/04/20/终于把Hexo服务器弄好了/","link":"","permalink":"http://tk820723.github.io/2016/04/20/终于把Hexo服务器弄好了/","excerpt":"","keywords":null,"text":"折腾半天终于把Hexo服务器弄好了，主要是各种装了一半失败，然后查阅资料，原来是翻墙的原因。翻了墙之后又遇到国内hexo2.0和3.0教程不兼容问题，公司网络连接github也是时好时坏，磕磕碰碰终于搞好了一个网站。可以用来装逼了哈哈。下面👇全是学习hexo的测试。 这是一段blockquote Weibai LuQueteMe.com Code Block1NSLog(@\"Hello codeblock!\");","raw":null,"content":null,"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://tk820723.github.io/categories/Hexo/"}],"tags":[]}]}